<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The Cabin</title>
  <style>
    :root {
      --bg: #0a0a0a;
      --text: #c8c8c8;
      --dim: #666;
      --prompt-color: #888;
      --cursor: #c8c8c8;
    }

    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    html, body {
      height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
      font-size: 15px;
      line-height: 1.5;
    }

    /* Subtle noise overlay */
    body::after {
      content: "";
      position: fixed;
      inset: 0;
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='200' height='200'><filter id='n'><feTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/></filter><rect width='100%' height='100%' filter='url(%23n)' opacity='0.15'/></svg>");
      opacity: 0.04;
      mix-blend-mode: screen;
      pointer-events: none;
      z-index: 999;
    }

    #terminal {
      display: flex;
      flex-direction: column;
      height: 100vh;
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem 1.5rem 1rem;
    }

    #output {
      flex: 1;
      overflow-y: auto;
      padding-bottom: 1rem;
      scrollbar-width: thin;
      scrollbar-color: #333 transparent;
    }

    #output::-webkit-scrollbar { width: 6px; }
    #output::-webkit-scrollbar-track { background: transparent; }
    #output::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }

    .block {
      margin-bottom: 1.2rem;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .block.room-title {
      color: #e0e0e0;
      font-weight: bold;
    }

    .block.separator {
      color: var(--dim);
      margin-bottom: 0.3rem;
    }

    .block.status {
      color: var(--dim);
      font-size: 0.85em;
    }

    .block.prompt-text {
      color: var(--dim);
      margin-bottom: 0.4rem;
    }

    .block.input-echo {
      color: var(--prompt-color);
    }

    .block.italic {
      font-style: italic;
      color: #999;
    }

    .block.game-over {
      color: #a33;
      font-weight: bold;
      margin-top: 1rem;
    }

    .block.error {
      color: #a33;
    }

    .block.system {
      color: var(--dim);
      font-style: italic;
      font-size: 0.85em;
    }

    /* Keypress hint */
    .keypress-hint {
      color: var(--dim);
      font-size: 0.8em;
      margin-top: 0.5rem;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }

    /* Input area */
    #input-area {
      display: flex;
      align-items: center;
      padding: 0.6rem 0;
      border-top: 1px solid #1a1a1a;
    }

    #input-area.hidden { display: none; }

    #input-prefix {
      color: var(--prompt-color);
      margin-right: 0.4rem;
      user-select: none;
      flex-shrink: 0;
    }

    #input {
      flex: 1;
      background: transparent;
      border: none;
      outline: none;
      color: var(--text);
      font-family: inherit;
      font-size: inherit;
      line-height: inherit;
      caret-color: var(--cursor);
    }

    #input::placeholder {
      color: #333;
    }

    /* Connection status */
    #status-bar {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.4rem 0;
      font-size: 0.75em;
      color: var(--dim);
      user-select: none;
    }

    .dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #333;
    }

    .dot.connected { background: #494; }
    .dot.error { background: #944; }
  </style>
</head>
<body>
  <div id="terminal">
    <div id="output"></div>
    <div id="input-area" class="hidden">
      <span id="input-prefix">&gt;</span>
      <input id="input" type="text" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="" />
    </div>
    <div id="status-bar">
      <span class="dot" id="conn-dot"></span>
      <span id="conn-text">connecting…</span>
    </div>
  </div>

<script>
(function () {
  const WS_URL = location.hostname === "127.0.0.1" || location.hostname === "localhost"
    ? "ws://127.0.0.1:8080/ws"
    : "wss://the-cabin-api.fly.dev/ws";

  const output   = document.getElementById("output");
  const inputArea = document.getElementById("input-area");
  const inputEl  = document.getElementById("input");
  const inputPfx = document.getElementById("input-prefix");
  const connDot  = document.getElementById("conn-dot");
  const connText = document.getElementById("conn-text");

  let ws = null;
  let mode = "connecting"; // "connecting" | "keypress" | "input" | "ended"

  function setStatus(state, text) {
    connDot.className = "dot " + state;
    connText.textContent = text;
  }

  function scrollToBottom() {
    requestAnimationFrame(() => {
      const last = output.lastElementChild;
      if (last) {
        last.scrollIntoView({ behavior: "smooth", block: "end" });
      } else {
        output.scrollTop = output.scrollHeight;
      }
    });
  }

  function addBlock(text, cls) {
    const el = document.createElement("div");
    el.className = "block" + (cls ? " " + cls : "");
    el.textContent = text;
    output.appendChild(el);
  }

  function clearOutput() {
    output.innerHTML = "";
  }

  function renderFrame(data) {
    if (data.clear) {
      clearOutput();
    }

    // Render lines with smart styling
    const lines = data.lines || [];
    let i = 0;
    while (i < lines.length) {
      const line = lines[i];

      // Detect room title + separator pattern
      if (i + 1 < lines.length && /^-{3,}$/.test(lines[i + 1])) {
        addBlock(line, "room-title");
        addBlock(lines[i + 1], "separator");
        i += 2;
        continue;
      }

      // Status line
      if (/^Health:\s*\d+/.test(line)) {
        addBlock(line, "status");
        i++;
        continue;
      }

      // "What would you like to do?"
      if (/what would you like/i.test(line)) {
        addBlock(line, "prompt-text");
        i++;
        continue;
      }

      // Italic markers
      if (/^\*.*\*$/.test(line.trim())) {
        addBlock(line.replace(/^\*|\*$/g, ""), "italic");
        i++;
        continue;
      }

      // "Press any key" hint
      if (/press any key/i.test(line)) {
        const hint = document.createElement("div");
        hint.className = "keypress-hint";
        hint.textContent = line;
        output.appendChild(hint);
        i++;
        continue;
      }

      // Regular line (or blank)
      addBlock(line, "");
      i++;
    }

    // Determine interaction mode
    if (data.game_over) {
      mode = "ended";
      inputArea.classList.add("hidden");
      addBlock("", "");
      addBlock("[session ended — refresh to restart]", "system");
    } else if (data.wait_for_key) {
      mode = "keypress";
      inputArea.classList.add("hidden");
    } else if (data.prompt) {
      mode = "input";
      inputPfx.textContent = data.prompt;
      inputArea.classList.remove("hidden");
      inputEl.value = "";
      inputEl.focus();
    } else {
      // Default: show input
      mode = "input";
      inputArea.classList.remove("hidden");
      inputEl.value = "";
      inputEl.focus();
    }

    scrollToBottom();
  }

  function sendKeypress() {
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: "keypress" }));
    }
  }

  function sendInput(text) {
    if (ws && ws.readyState === WebSocket.OPEN) {
      // Echo the input
      addBlock("> " + text, "input-echo");
      scrollToBottom();
      ws.send(JSON.stringify({ type: "input", text: text }));
    }
  }

  function connect() {
    setStatus("", "connecting…");
    mode = "connecting";

    ws = new WebSocket(WS_URL);

    ws.onopen = function () {
      setStatus("connected", "connected");
    };

    ws.onmessage = function (ev) {
      let data;
      try {
        data = JSON.parse(ev.data);
      } catch (e) {
        return;
      }

      if (data.type === "error") {
        addBlock(data.message, "error");
        scrollToBottom();
        return;
      }

      if (data.type === "render") {
        renderFrame(data);
      }
    };

    ws.onclose = function () {
      setStatus("error", "disconnected");
      if (mode !== "ended") {
        addBlock("", "");
        addBlock("[connection lost — refresh to reconnect]", "system");
        mode = "ended";
        inputArea.classList.add("hidden");
      }
    };

    ws.onerror = function () {
      setStatus("error", "error");
    };
  }

  // Global key listener for keypress mode
  document.addEventListener("keydown", function (ev) {
    if (mode === "keypress") {
      ev.preventDefault();
      sendKeypress();
      return;
    }

    // Focus input if typing and not already focused
    if (mode === "input" && document.activeElement !== inputEl) {
      if (ev.key.length === 1 && !ev.ctrlKey && !ev.metaKey && !ev.altKey) {
        inputEl.focus();
      }
    }
  });

  // Click anywhere to focus input
  document.addEventListener("click", function () {
    if (mode === "input") {
      inputEl.focus();
    } else if (mode === "keypress") {
      sendKeypress();
    }
  });

  // Submit input on Enter
  inputEl.addEventListener("keydown", function (ev) {
    if (ev.key === "Enter") {
      ev.preventDefault();
      const text = inputEl.value.trim();
      if (text === "") return;
      sendInput(text);
      inputEl.value = "";
      inputArea.classList.add("hidden");
      mode = "connecting"; // wait for server response
    }
  });

  connect();
})();
</script>
</body>
</html>
